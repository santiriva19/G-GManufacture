{"ast":null,"code":"import pathToRegexp from 'path-to-regexp';\n/**\n *\n * This set of functions are used to match a url with a uri path.\n * This functionality is based on the internals of React-Router's matchPath.\n * - https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/matchPath.md\n *\n */\n\n/**\n * This function accepts a uri path and returns a regex to match that path\n * against a url and an array of the keys extracted from that uri path\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n *\n * Sample Input: \"/user/:id/\"\n *\n * Sample Output:\n * {\n *     re: /^\\/user\\/([^\\/]+?)\\/(?:\\/(?=$))?/i,\n *     keys: [\n *         name: \"id\"\n *         delimiter: \"/\"\n *         optional: false\n *         partial: false\n *         path: \"[^\\/]+?\"\n *         prefix: \"/\"\n *         repeat: false,\n *     ]\n * }\n */\n\nconst compilePathToRegex = path => {\n  const keys = [];\n  const re = pathToRegexp(path, keys); // Returns the regex path to match a uri path to an actual url\n  // and the keys that can be used to pull values from the url.\n\n  return {\n    re,\n    keys\n  };\n};\n/**\n * This function accepts a uri path and an actual url. It determines whether\n * or not they match one another. If they do not match, the funtion returns null.\n * If they do match, then the function returns the path and the params parsed\n * from the url.\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match the given path\n *\n * Case 1 - path Does Not Match Url:\n *   Sample Input: (path: \"/edit/organization/(:id)\", url: \"/user/300002/\")\n *\n *   Sample Output: null\n *\n * Case 2 - path Does Match Url:\n *   Sample Input: (path: \"/user/:id/\", url: \"/user/300002/\")\n *\n *   Sample Output:\n *   {\n *       path: \"/user/:id/\",\n *       params: {\n *           id: \"300002\",\n *       }\n *   }\n *\n */\n\n\nexport const matchPath = (path, url) => {\n  // Remove possible query fragments, which are not supported by iOS and some\n  // versions of Anroid.\n  const [urlCleaned] = url.split('?'); // Append trailing slash for compatibility with pathToRegexp\n\n  const urlToMatch = !urlCleaned.endsWith('/') ? `${urlCleaned}/` : urlCleaned; // Return the regex and the keys that can be parsed from a uri path.\n\n  const {\n    re,\n    keys\n  } = compilePathToRegex(path); // Check if the given url matches the uri path.\n\n  const match = re.exec(urlToMatch); // If there is no match, then return null.\n\n  if (!match) {\n    return null;\n  } // Destructure to return the compiled url (aka the reconstructed url based\n  // on the regex and the url parameters.\n\n\n  const [compiledUrl, ...values] = match; // If there is an inexact match (aka the compiled path does not match the\n  // given url, then return null)\n\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  const params = keys.reduce((acc, key, index) => Object.assign({}, acc, {\n    [key.name]: values[index]\n  }), {});\n  return {\n    path,\n    params\n  };\n};\n/**\n * This function accepts an array of uri paths and a url. If there are no paths\n * in the array that match the given url, then the function will return null.\n * If there is at least one matching uri path, it will return the first\n * matching path and the parsed url parameters (the output from matchPath()).\n *\n * @param {Array} possibleMatchingpaths - an array of uri paths in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match a given path\n *\n */\n\nconst pathParser = (url, possibleMatchingpaths = []) => possibleMatchingpaths.map(path => matchPath(path, url)).find(obj => obj);\n\nexport default pathParser;","map":{"version":3,"sources":["/Volumes/DISCO RIVA/Proyectos/ReactJS/G&GManufacture/node_modules/react-native-router-flux/src/pathParser.js"],"names":["pathToRegexp","compilePathToRegex","path","keys","re","matchPath","url","urlCleaned","split","urlToMatch","endsWith","match","exec","compiledUrl","values","params","reduce","acc","key","index","Object","assign","name","pathParser","possibleMatchingpaths","map","find","obj"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,gBAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,kBAAkB,GAAIC,IAAD,IAAU;AACnC,QAAMC,IAAI,GAAG,EAAb;AACA,QAAMC,EAAE,GAAGJ,YAAY,CAACE,IAAD,EAAOC,IAAP,CAAvB,CAFmC,CAGnC;AACA;;AACA,SAAO;AAAEC,IAAAA,EAAF;AAAMD,IAAAA;AAAN,GAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,SAAS,GAAG,CAACH,IAAD,EAAOI,GAAP,KAAe;AACtC;AACA;AACA,QAAM,CAACC,UAAD,IAAeD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAArB,CAHsC,CAKtC;;AACA,QAAMC,UAAU,GAAG,CAACF,UAAU,CAACG,QAAX,CAAoB,GAApB,CAAD,GAA6B,GAAEH,UAAW,GAA1C,GAA+CA,UAAlE,CANsC,CAQtC;;AACA,QAAM;AAAEH,IAAAA,EAAF;AAAMD,IAAAA;AAAN,MAAeF,kBAAkB,CAACC,IAAD,CAAvC,CATsC,CAWtC;;AACA,QAAMS,KAAK,GAAGP,EAAE,CAACQ,IAAH,CAAQH,UAAR,CAAd,CAZsC,CActC;;AACA,MAAI,CAACE,KAAL,EAAY;AACV,WAAO,IAAP;AACD,GAjBqC,CAmBtC;AACA;;;AACA,QAAM,CAACE,WAAD,EAAc,GAAGC,MAAjB,IAA2BH,KAAjC,CArBsC,CAuBtC;AACA;;AACA,MAAIF,UAAU,KAAKI,WAAnB,EAAgC;AAC9B,WAAO,IAAP;AACD;;AAED,QAAME,MAAM,GAAGZ,IAAI,CAACa,MAAL,CAAY,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,GAAlB,EAAuB;AAAE,KAACC,GAAG,CAACI,IAAL,GAAYR,MAAM,CAACK,KAAD;AAApB,GAAvB,CAAjC,EAAwF,EAAxF,CAAf;AAEA,SAAO;AAAEjB,IAAAA,IAAF;AAAQa,IAAAA;AAAR,GAAP;AACD,CAhCM;AAkCP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMQ,UAAU,GAAG,CAACjB,GAAD,EAAMkB,qBAAqB,GAAG,EAA9B,KAAqCA,qBAAqB,CAACC,GAAtB,CAA0BvB,IAAI,IAAIG,SAAS,CAACH,IAAD,EAAOI,GAAP,CAA3C,EAAwDoB,IAAxD,CAA6DC,GAAG,IAAIA,GAApE,CAAxD;;AAEA,eAAeJ,UAAf","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\n/**\n *\n * This set of functions are used to match a url with a uri path.\n * This functionality is based on the internals of React-Router's matchPath.\n * - https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/matchPath.md\n *\n */\n\n/**\n * This function accepts a uri path and returns a regex to match that path\n * against a url and an array of the keys extracted from that uri path\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n *\n * Sample Input: \"/user/:id/\"\n *\n * Sample Output:\n * {\n *     re: /^\\/user\\/([^\\/]+?)\\/(?:\\/(?=$))?/i,\n *     keys: [\n *         name: \"id\"\n *         delimiter: \"/\"\n *         optional: false\n *         partial: false\n *         path: \"[^\\/]+?\"\n *         prefix: \"/\"\n *         repeat: false,\n *     ]\n * }\n */\nconst compilePathToRegex = (path) => {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n  // Returns the regex path to match a uri path to an actual url\n  // and the keys that can be used to pull values from the url.\n  return { re, keys };\n};\n\n/**\n * This function accepts a uri path and an actual url. It determines whether\n * or not they match one another. If they do not match, the funtion returns null.\n * If they do match, then the function returns the path and the params parsed\n * from the url.\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match the given path\n *\n * Case 1 - path Does Not Match Url:\n *   Sample Input: (path: \"/edit/organization/(:id)\", url: \"/user/300002/\")\n *\n *   Sample Output: null\n *\n * Case 2 - path Does Match Url:\n *   Sample Input: (path: \"/user/:id/\", url: \"/user/300002/\")\n *\n *   Sample Output:\n *   {\n *       path: \"/user/:id/\",\n *       params: {\n *           id: \"300002\",\n *       }\n *   }\n *\n */\nexport const matchPath = (path, url) => {\n  // Remove possible query fragments, which are not supported by iOS and some\n  // versions of Anroid.\n  const [urlCleaned] = url.split('?');\n\n  // Append trailing slash for compatibility with pathToRegexp\n  const urlToMatch = !urlCleaned.endsWith('/') ? `${urlCleaned}/` : urlCleaned;\n\n  // Return the regex and the keys that can be parsed from a uri path.\n  const { re, keys } = compilePathToRegex(path);\n\n  // Check if the given url matches the uri path.\n  const match = re.exec(urlToMatch);\n\n  // If there is no match, then return null.\n  if (!match) {\n    return null;\n  }\n\n  // Destructure to return the compiled url (aka the reconstructed url based\n  // on the regex and the url parameters.\n  const [compiledUrl, ...values] = match;\n\n  // If there is an inexact match (aka the compiled path does not match the\n  // given url, then return null)\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  const params = keys.reduce((acc, key, index) => Object.assign({}, acc, { [key.name]: values[index] }), {});\n\n  return { path, params };\n};\n\n/**\n * This function accepts an array of uri paths and a url. If there are no paths\n * in the array that match the given url, then the function will return null.\n * If there is at least one matching uri path, it will return the first\n * matching path and the parsed url parameters (the output from matchPath()).\n *\n * @param {Array} possibleMatchingpaths - an array of uri paths in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match a given path\n *\n */\nconst pathParser = (url, possibleMatchingpaths = []) => possibleMatchingpaths.map(path => matchPath(path, url)).find(obj => obj);\n\nexport default pathParser;\n"]},"metadata":{},"sourceType":"module"}